<!DOCTYPE html>
<html>
  <head>
    <title>pres</title>
    <meta charset="utf-8">
    <meta name="author" content="Amanda Dobbyn" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# pres
### Amanda Dobbyn

---





### warning, ‚ö†Ô∏è Warning: this presentation contains less rap than you might have expected. warning, ‚ö†Ô∏è

I won't blame you if you want to make a quick exit.

---

### Quick about me

Day job: ultimate frisbee player.

For fun: Data Scientist at Earlybird Software, former co-organizer of R-Ladies Chicago.

---

### `drake`'s main idea

`drake` is workflow manager for your R code.

In an R pipeline, when changes occur that make the most recent results out-of-date, rebuild *only* the parts of the pipeline that need to be rebuilt.

Created and maintained by [Will](https://twitter.com/wmlandau) [Landau](https://github.com/wlandau) and friends.

---

### What's the deal with the name?

**d**ataframes in **R** for M**ake**

[GNU Make](https://www.gnu.org/software/make/) uses workflow outline file called a Makefile to specify dependencies and how targets should be rebuilt when they're out of date. 

`drake` takes that idea and implements it in a way that's more native to how we work in R.

---

### Nice features of `drake`
1. See how your pipeline fits together, in a tidy dataframe
2. Visualize dependencies in your code in graph format
3. Some high-performance computing advantages
4. Great for iteration and reproducibility; you know exactly how these results were generated
5. It's all in R -- no writing config files!


You can avoid workflows like this, that are based on file names that could easily be out of date and rely on `source`ing the script before it.

01_import.R
02_clean.R
03_deep_clean.R
04_join.R
05_analyze.R
06_analyze_more.R
07_report.Rmd

If something breaks in 04_join.R, do you need to go through 01_import.R, 02_clean.R, and 03_deep_clean.R again?

---

### Analogy to `knitr`

(Stolen from Will's point in his [interview on the R podcast](https://www.youtube.com/watch?v=eJQ29CLyDCs&amp;feature=youtu.be&amp;t=1533).)

`drake` is sort of like `knitr` in the sense that 
1) It makes your analysis reproducible and compact. You expect to be able to rerun someone's report from a single file.

2) In `knitr`, chunks can be cached if they've already been run, so they don't need to be re-run unless something in them changes.

3) When an `Rmd` is knit, a chunk successfully knitting depends on the previous chunk knitting and on any chunk that you specify a `depedson` for.

---

### A few pieces of vocab

#### *targets* and *commands*

From `?drake_config`: "**Targets** are the objects and files that drake generates, and **commands** are the pieces of R code that produce them."

#### *plans*

**Plans** wrap up the relationship between targets and commands into a workflow representation.

In `drake` they're stored as a dataframe object, with one column for targets, and one column for their corresponding commands.

You can think of the plan as that top-level script that sources all the other scripts and runs everything, like


```r
source("01_import.R")
source("02_clean.R")
...
source("06_analyze_more.R")

final &lt;- do_more_things(object_in_env)

write_out_my_results(final)
```

except that it knows about the dependencies of all objects and functions and is less cumbersome than this setup.

---

### How to `drake`

1. Store prework (loading packages and user-defined functions) in a file 
2. Store a `drake` plan in another file
3. Create the plan and run it


```r
source("/path/to/my/prework.R")

## Custom functions defined in prework are:
# clean_my(), analyze_my(), and report_out_my()

plan &lt;- 
  drake_plan(
  cleaned_data = clean_my(raw_data),
  results = analyze_my(cleaned_data),
  report = report_out_my(results,
                         file_out = "/path/to/my/report.md")
)

make(plan)
```

The first run of `make(plan)` will run the plan from scratch. 

After that, `drake` will only re-run the parts of the plan that are out of date and everything downstream of that.

`drake` knows that, for example, `results` depends on `cleaned_data` because `cleaned_data` is part of the `analyze_my(cleaned_data)` command used to generate `results`.

---

### What makes a target become out of date?

1. Some part of the code used to generate that target or one of its upstream targets has changed
2. A trigger is activated (more on that later)

---

### Where is all this info stored?

How does `drake` store info/data about targets?

In a hidden `.drake` cache when you run `make()`. In the `.drake/data` subdirectory, targets are stored as hashed `rds` objects. [More on storage.](https://ropensci.github.io/drake/articles/storage.html)

`clean()` cleans that cache.

How does `drake` keep track of dependencies?

`drake` stores a dependency graph of the plan along with a bunch of other things in `config`, which you can access with `drake_config()`.

---

### Big Idea #2

`drake` is all built around *functions* rather than sourcing scripts.
- A plan works by using functions to create targets. 
- This allows `drake` to infer dependencies of objects and functions
- Running `drake_plan` creates a dataframe relating each target to the function used to generate it.



```r
bad_plan &lt;- 
  drake_plan(
    first_target = source("import.R"),
    second_target = source("clean.R")
  )
```

Sourcing files breaks the dependency structure that makes `drake` useful. 

Instead, 


```r
source("all_my_funs.R")

good_plan &lt;- 
  drake_plan(
    first_target = do_stuff(my_data),
    second_target = do_more_stuff(first_target)
  )
```

This setup allows `drake` to know `first_target` needs to be built before work on `second_target` can begin.

---

### Our plan

I'll illustrate a way you might want to use `drake` with something that's close to home for us.

Remember the [crazy blue light](https://twitter.com/NYCFireWire/status/1078478369036165121) from late December?

The Twitter account that let us know that this wasn't in fact aliens is [NYCFireWire](https://twitter.com/NYCFireWire).

Normally they just tweet out fires and their locations in a more or less predictable pattern, e.g.

https://twitter.com/NYCFireWire/status/1087888350277705728

What if we were constructing an analysis of these tweets and wanted to make sure our pipeline worked end-to-end, but didn't want to unnecessarily re-run outdated parts of it unless we needed to?

---

### The Pipeline

1. Pull in tweets, either the first big batch or any new ones that show up
2. Extract addresses from the tweets (üé∂ regex time üé∂)
3. Send these to the Google Maps API to grab the addresses' latitudes and longitudes
4. Profit

All functions stored in `didnt_start_it.R`.


```r
source(here::here("didnt_start_it.R"))
```

```
## Warning: package 'tibble' was built under R version 3.5.2
```


---

### Grabbing tweets

- `get_seed_tweets` grabs a batch of tweets *or* reads in seed tweets from a file if the file exists
- `get_more_tweets` checks if there are new tweets and, if so, pulls in the right number of them
- `get_tweets` runs `get_seed_tweets` if given a null `tbl` argument, otherwise runs `get_more_tweets`



For example, starting with an old tweet ID, we can first grab a 10 tweets older than `old_tweet_id` and then, running the same function again, add 5 of the most recent tweets to our dataframe.


```r
get_tweets()
```

```
## # A tibble: 50 x 5
##    text                   user_id status_id created_at          screen_name
##    &lt;chr&gt;                    &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;chr&gt;      
##  1 Queens *Water Rescue*‚Ä¶  5.60e8   1.09e18 2019-01-27 17:21:23 NYCFireWire
##  2 Brooklyn *77-75-2597*‚Ä¶  5.60e8   1.09e18 2019-01-27 16:10:36 NYCFireWire
##  3 Brooklyn *77-75-0805*‚Ä¶  5.60e8   1.09e18 2019-01-27 11:36:52 NYCFireWire
##  4 Staten Island *88-75-‚Ä¶  5.60e8   1.09e18 2019-01-27 11:10:49 NYCFireWire
##  5 Brooklyn *77-75-0689*‚Ä¶  5.60e8   1.09e18 2019-01-27 01:36:24 NYCFireWire
##  6 The FDNY‚Äôs diversity ‚Ä¶  5.60e8   1.09e18 2019-01-27 01:12:13 NYCFireWire
##  7 Fairfax County Fire &amp;‚Ä¶  5.60e8   1.09e18 2019-01-27 01:11:39 NYCFireWire
##  8 https://t.co/dnYTm4ZA‚Ä¶  5.60e8   1.09e18 2019-01-26 23:06:02 NYCFireWire
##  9 Queens *99-75-6833* 1‚Ä¶  5.60e8   1.09e18 2019-01-26 21:05:04 NYCFireWire
## 10 Queens *99-75-4187* 5‚Ä¶  5.60e8   1.09e18 2019-01-26 20:14:02 NYCFireWire
## # ‚Ä¶ with 40 more rows
```

```r
old_tweet_id &lt;- "1084619203167031297" # Random tweet from a while ago so what we can set a max id in the past

seed_tweets &lt;- 
  get_tweets(
    n_tweets_seed = 10,
    max_id = old_tweet_id
  )

(full_tweets &lt;- 
  get_tweets(seed_tweets, n_tweets_reup = 5))
```

```
## Searching for new tweets.
```

```
## 5 new tweet(s) pulled.
```

```
## # A tibble: 15 x 5
##    text                   user_id status_id created_at          screen_name
##    &lt;chr&gt;                    &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;chr&gt;      
##  1 Queens *Water Rescue*‚Ä¶  5.60e8   1.09e18 2019-01-27 17:21:23 NYCFireWire
##  2 Brooklyn *77-75-2597*‚Ä¶  5.60e8   1.09e18 2019-01-27 16:10:36 NYCFireWire
##  3 Brooklyn *77-75-0805*‚Ä¶  5.60e8   1.09e18 2019-01-27 11:36:52 NYCFireWire
##  4 Staten Island *88-75-‚Ä¶  5.60e8   1.09e18 2019-01-27 11:10:49 NYCFireWire
##  5 Brooklyn *77-75-0689*‚Ä¶  5.60e8   1.09e18 2019-01-27 01:36:24 NYCFireWire
##  6 "Staten Island *MVA/P‚Ä¶  5.60e8   1.08e18 2019-01-13 20:12:23 NYCFireWire
##  7 Queens 99-75-6810 111‚Ä¶  5.60e8   1.08e18 2019-01-13 17:57:22 NYCFireWire
##  8 Manhattan *66-75-1352‚Ä¶  5.60e8   1.08e18 2019-01-13 04:27:44 NYCFireWire
##  9 Staten Island *88-75-‚Ä¶  5.60e8   1.08e18 2019-01-13 03:15:46 NYCFireWire
## 10 Firefighter in harass‚Ä¶  5.60e8   1.08e18 2019-01-12 22:10:35 NYCFireWire
## 11 Mom whose tot started‚Ä¶  5.60e8   1.08e18 2019-01-12 21:33:46 NYCFireWire
## 12 Much love &amp;amp; appre‚Ä¶  5.60e8   1.08e18 2019-01-12 19:24:44 NYCFireWire
## 13 FCC: New York is siph‚Ä¶  5.60e8   1.08e18 2019-01-12 17:09:36 NYCFireWire
## 14 God bless the #NYPD h‚Ä¶  5.60e8   1.08e18 2019-01-12 16:46:34 NYCFireWire
## 15 Pregnant FDNY worker ‚Ä¶  5.60e8   1.08e18 2019-01-12 09:12:38 NYCFireWire
```

### Getting addresses




```r
get_tweets() %&gt;% 
  pull_addresses() %&gt;% 
  select(street, borough, address, text)
```

```
## Source: local data frame [50 x 4]
## Groups: &lt;by row&gt;
## 
## # A tibble: 50 x 4
##    street         borough   address              text                      
##    &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;                &lt;chr&gt;                     
##  1 Howard Beach ‚Ä¶ Queens    Howard Beach Motor ‚Ä¶ Queens *Water Rescue* How‚Ä¶
##  2 785 E 4th St ‚Ä¶ Brooklyn  785 E 4th St off Av‚Ä¶ Brooklyn *77-75-2597* 785‚Ä¶
##  3 1259 Madison ‚Ä¶ Brooklyn  1259 Madison St, Br‚Ä¶ Brooklyn *77-75-0805* 125‚Ä¶
##  4 280 Park Hill‚Ä¶ Staten I‚Ä¶ 280 Park Hill Ave o‚Ä¶ Staten Island *88-75-0460‚Ä¶
##  5 188 Garvey Bl‚Ä¶ Brooklyn  188 Garvey Blvd, Br‚Ä¶ Brooklyn *77-75-0689* 188‚Ä¶
##  6 &lt;NA&gt;           &lt;NA&gt;      &lt;NA&gt;                 The FDNY‚Äôs diversity moni‚Ä¶
##  7 &lt;NA&gt;           &lt;NA&gt;      &lt;NA&gt;                 Fairfax County Fire &amp;amp;‚Ä¶
##  8 &lt;NA&gt;           &lt;NA&gt;      &lt;NA&gt;                 https://t.co/dnYTm4ZAAU   
##  9 115-87 229 St  Queens    115-87 229 St, Quee‚Ä¶ Queens *99-75-6833* 115-8‚Ä¶
## 10 54-02 Flushin‚Ä¶ Queens    54-02 Flushing Ave,‚Ä¶ Queens *99-75-4187* 54-02‚Ä¶
## # ‚Ä¶ with 40 more rows
```


Then we can use the [`geocode`](https://www.rdocumentation.org/packages/ggmap/versions/2.6.1/topics/geocode) function (along with a [Google Maps](https://cloud.google.com/maps-platform/) API key) from the `ggmap` package to attach the latitude and longitude to each address, if Google can find it. (Otherwise we're returned `NA`s.)


```r
geo_to_list
```

```
## function (inp) 
## {
##     geocode(inp) %&gt;% rename(long = lon) %&gt;% list()
## }
```

```r
truncate_lat_long
```

```
## function (tbl, digits = 3) 
## {
##     if (!"long" %in% names(tbl) || !"lat" %in% names(tbl)) {
##         stop("Input must contain columns lat and long.")
##     }
##     tbl %&gt;% mutate(lat_trunc = round(lat, digits = digits), long_trunc = round(long, 
##         digits = digits))
## }
```

```r
get_lat_long
```

```
## function (tbl) 
## {
##     tbl %&gt;% rowwise() %&gt;% mutate(l_l = ifelse(is.na(address), 
##         tibble(lat = NA_real_, long = NA_real_) %&gt;% list(), geo_to_list(address))) %&gt;% 
##         unnest() %&gt;% truncate_lat_long(digits = 1) %&gt;% select(address, 
##         lat, long, lat_trunc, long_trunc, created_at, text)
## }
```


```r
get_tweets(n_tweets_seed = 5) %&gt;% 
  pull_addresses() %&gt;% 
  get_lat_long()
```

```
## Source : https://maps.googleapis.com/maps/api/geocode/json?address=Howard%20Beach%20Motor%20Boat%20Club%2C%20Queens&amp;key=xxx
```

```
## Source : https://maps.googleapis.com/maps/api/geocode/json?address=785%20E%204th%20St%20off%20Avenue%20F%2C%20Brooklyn&amp;key=xxx
```

```
## Source : https://maps.googleapis.com/maps/api/geocode/json?address=1259%20Madison%20St%2C%20Brooklyn&amp;key=xxx
```

```
## Source : https://maps.googleapis.com/maps/api/geocode/json?address=280%20Park%20Hill%20Ave%20off%20Sobel%20ct%2C%20Staten%20Island&amp;key=xxx
```

```
## Source : https://maps.googleapis.com/maps/api/geocode/json?address=188%20Garvey%20Blvd%2C%20Brooklyn&amp;key=xxx
```

```
## # A tibble: 5 x 7
##   address      lat  long lat_trunc long_trunc created_at          text     
##   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dttm&gt;              &lt;chr&gt;    
## 1 Howard Be‚Ä¶  40.7 -73.8      40.7      -73.8 2019-01-27 17:21:23 Queens *‚Ä¶
## 2 785 E 4th‚Ä¶  40.6 -74.0      40.6      -74   2019-01-27 16:10:36 Brooklyn‚Ä¶
## 3 1259 Madi‚Ä¶  40.7 -73.9      40.7      -73.9 2019-01-27 11:36:52 Brooklyn‚Ä¶
## 4 280 Park ‚Ä¶  40.6 -74.1      40.6      -74.1 2019-01-27 11:10:49 Staten I‚Ä¶
## 5 188 Garve‚Ä¶  40.7 -73.9      40.7      -73.9 2019-01-27 01:36:24 Brooklyn‚Ä¶
```


That's our main pipeline. We can do a few bits of analysis of the data after that, but that's the core of it.

### Other things `drake` can do that we won't get into

- [Generating ~ big plans ~](https://ropensci.github.io/drake/articles/best-practices.html#generating-workflow-plan-data-frames)

![big_plans](https://media.giphy.com/media/DCslYLxUUgKX2ms0iw/giphy.gif)

for analyses that require lots of different permutations of a similar analysis

(version 7.0.0 has new experimental syntax that makes it easier to create big plans)

- Support for [debugging and testing ](https://ropenscilabs.github.io/drake-manual/debug.html) plans

- Compatibility with [high performance computing](https://ropenscilabs.github.io/drake-manual/hpc.html) backends


### Moar Resources

- [`drake` user manual](https://ropenscilabs.github.io/drake-manual/index.html)
- [debugging drake](https://ropensci.github.io/drake/articles/debug.html)
- [Sina R√ºeger's `drake` presentation](https://sinarueeger.github.io/2018/10/09/workflow/)
- [Kirill M√ºller's cheat sheet](https://github.com/krlmlr/drake-sib-zurich/blob/master/cheat-sheet.pdf)
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
